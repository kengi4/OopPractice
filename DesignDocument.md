# Design Document: OopPractice CLI Application

---

## 1. Вступ
Цей документ описує архітектуру та деталі реалізації консольного додатка, розробленого в рамках курсу ООП. Проєкт об'єднує в собі функціонал менеджера файлів, каталогу RPG-персонажів та текстової рольової гри.

**Головна мета:** Створення гнучкої, модульної архітектури, яка дозволяє легко додавати нові команди та режими роботи без зміни основного коду, використовуючи принципи SOLID та патерни проєктування.

---

## 2. Архітектура Системи

Додаток побудований за тришаровою архітектурою з акцентом на слабку зв'язаність (Loose Coupling).

### 2.1. Основні шари
1.  **Presentation Layer (Шар представлення):**
    * Відповідає за взаємодію з користувачем через консоль.
    * Містить класи `CliManager`, `IRenderer`, `IConsoleDriver`.
2.  **Logic/Core Layer (Шар бізнес-логіки):**
    * Містить сутності (`Character`, `Warrior`, `Mage`), логіку бою та управління файлами.
    * Визначає інтерфейси для стратегій (`ICommandStrategy`, `IAttackStrategy`).
3.  **Data Layer (Шар даних):**
    * Відповідає за збереження та завантаження стану.
    * Реалізовано через клас `Repository`, який серіалізує об'єкти в JSON.

---

## 3. Деталізація Командного Інтерфейсу (CLI)

Центральним елементом системи є гнучкий CLI, побудований на комбінації патернів **Facade**, **Strategy** та **Renderer**.

### 3.1. Патерн "Facade" (`CliManager`)
Клас `CliManager` виступає єдиною точкою входу для користувацького вводу.
* **Відповідальність:** Запускає цикл `Read-Eval-Print Loop` (REPL), парсить введені рядки на команди та аргументи.
* **Особливість:** Він не знає, як виконувати команди. Він лише делегує їх відповідним зареєстрованим делегатам (`Action<string[]>`).

### 3.2. Патерн "Strategy" (`ICommandStrategy`)
Для розділення логіки різних модулів використовується інтерфейс `ICommandStrategy`. Це дозволяє групувати команди за контекстом:
* **`CharacterManagementStrategy`**: Інкапсулює логіку роботи з персонажами (створення, перегляд, збереження). Реєструє команди: `create-char`, `ls-chars`, `info`, `save`.
* **`FileSystemStrategy` (Опціонально)**: Інкапсулює логіку роботи з файлами (`cd`, `dir`, `edit`).

*Перевага:* Щоб додати новий модуль (наприклад, "Магазин предметів"), потрібно лише створити нову стратегію та підключити її в `Program.cs` через `cli.UseStrategy(...)`.

### 3.3. Патерн "Renderer" (Розділення Представлення)
Для відділення логіки даних від їх візуалізації застосовано принцип інверсії залежностей.
* **Проблема:** Клас `Character` не повинен мати методів `PrintToConsole()`, оскільки це порушує SRP (Single Responsibility Principle).
* **Рішення:** Створено узагальнений інтерфейс `IRenderer<T>`.
    * Стратегія отримує дані (об'єкт `Character`).
    * Стратегія передає дані у `CharacterConsoleRenderer`.
    * Рендерер, використовуючи `IConsoleDriver`, формує красивий вивід (кольори, форматування).

---

## 4. Використані Патерни Проєктування

Проєкт активно використовує класичні GoF патерни:

| Патерн | Де використовується | Опис |
| :--- | :--- | :--- |
| **State (Стан)** | `FileManager` | Реалізує переходи між режимами: Навігація ↔ Перегляд файлу ↔ Редагування. |
| **Strategy (Стратегія)** | `CliManager`, `Character` | 1. Підключення груп команд CLI.<br>2. Реалізація різних типів атак (`MightyAxeStrategy`). |
| **Observer (Спостерігач)** | `BattleLogger` | Логування подій бою (отримання урону, смерть) без зміни коду персонажа. |
| **Memento (Знімок)** | `CharacterMemento` | Збереження стану персонажа для запису на диск. |
| **Factory Method** | `CharacterManagementStrategy` | Логіка створення персонажів (`Warrior` vs `Mage`) залежно від вибору користувача. |
| **Facade** | `CliManager` | Спрощений інтерфейс для роботи зі складною системою команд. |

---

## 5. Потік Даних (Data Flow)

**Сценарій: Створення персонажа**

1.  **Input:** Користувач вводить `create-char`.
2.  **Routing:** `CliManager` знаходить зареєстрований `Action` для цього ключа.
3.  **Processing:** Викликається метод `CreateCharacter` у `CharacterManagementStrategy`.
4.  **Interaction:** Користувач вводить ім'я та клас через консольний діалог.
5.  **Instantiation:** Створюється об'єкт `Warrior` або `Mage`.
6.  **Storage:** Об'єкт додається у локальний список `_characters`.
7.  **Feedback:** Виводиться повідомлення про успіх.

**Сценарій: Вивід інформації (`info`)**

1.  **Input:** Користувач вводить `info Conan`.
2.  **Search:** Стратегія шукає об'єкт в пам'яті за іменем.
3.  **Rendering:** Знайдений об'єкт передається у `_charRenderer.Render(character)`.
4.  **Output:** Рендерер малює кольорову картку персонажа в консоль.

---

## 6. Збереження Даних

Дані зберігаються у форматі **JSON** у файлі `gamestate.json`.
* Використовується клас `Repository`.
* При збереженні об'єкти конвертуються у DTO (`CharacterData`), щоб уникнути циклічних посилань та зберегти лише важливі дані.
* При завантаженні відбувається реконструкція об'єктів та відновлення їх стану через Memento.

---

## 7. Можливості для розширення

Архітектура дозволяє легко додати:
* **Графічний інтерфейс (GUI):** Достатньо написати нову реалізацію `IRenderer` (наприклад, `WpfRenderer`), не змінюючи логіку стратегій.
* **Мережева гра:** `CliManager` може приймати команди не з `Console.ReadLine`, а з мережевого сокету.
* **Нові ігрові механіки:** Додавання інвентарю або квестів через нові `ICommandStrategy`.

## 8. Бойова Система (Core Mechanics)

### 8.1. Формули розрахунку
В грі використовується система покрокового бою. Розрахунок пошкоджень відбувається за наступною формулою:

**Фізична атака:**
`Damage = max(0, Attacker.AttackPower - Target.Armor)`

**Магічна атака (Fireball):**
Магія ігнорує броню, але має фіксований урон.
`MagicDamage = SpellBaseDamage`

**Критичний удар (для Warrior):**
Шанс 20% нанести 150% шкоди.
`CritDamage = Damage * 1.5`

### 8.2. Структура ходу (Turn System)
Бій поділяється на раунди. У кожному раунді:
1. Визначається ініціатива (хто ходить першим).
2. Персонаж обирає дію (Атака, Здібність, Лікування).
3. Дія виконується, стан персонажів оновлюється.
4. Подія записується в `BattleHistory`.
5. Перевірка умов перемоги (HP <= 0).

### 8.3. Класи Core
* `GameSession`: Керує циклом гри, зберігає список гравців.
* `Turn`: Зберігає інформацію про одну дію (хто, кого, скільки урону).
* `BattleHistory`: Список всіх ходів для перегляду після бою.

## 9. Постійність даних (Data Persistence)

### 9.1. Механізм збереження
Для забезпечення постійності даних між сесіями використовується механізм серіалізації.
* **Формат:** JSON (JavaScript Object Notation). Обраний через легкість читання людиною та нативну підтримку в .NET.
* **Бібліотека:** `System.Text.Json`.

### 9.2. Розташування файлів
Відповідно до best practices, файли збереження не записуються в кореневу папку додатка. Використовується системний шлях `LocalApplicationData`:
* **Windows:** `C:\Users\{User}\AppData\Local\OopPracticeRPG\gamestate.json`
* **Linux/macOS:** `~/.local/share/OopPracticeRPG/gamestate.json`

### 9.3. Процес збереження (Serialization Flow)
1. Користувач викликає команду `save` або відбувається автозбереження.
2. `Repository` отримує список живих об'єктів `Character`.
3. Для кожного персонажа викликається патерн **Memento** (`SaveState`), щоб отримати чисті дані без циклічних посилань.
4. Дані конвертуються в DTO (`CharacterData`).
5. Об'єкт `GameState` серіалізується в рядок JSON і записується на диск.

### 9.4. Процес завантаження (Deserialization Flow)
1. При старті програми `CharacterManagementStrategy` звертається до `Repository`.
2. Репозиторій перевіряє наявність файлу.
3. JSON десеріалізується назад у список DTO.
4. Використовується **Factory Method** (або switch-case) для відновлення конкретних класів (`Warrior`/`Mage`) на основі поля `Type` із збереженого файлу.

## 10. Графічний Інтерфейс (GUI)

Для реалізації віконного режиму використано фреймворк **WPF (.NET)**. Це дозволяє зберегти строгу типізацію C# та використати існуючу бізнес-логіку без змін.

### 10.1. Архітектурні рішення
* **Патерн Adapter:** Клас `WpfDisplayer` реалізує інтерфейс `IDisplayer`. Він перехоплює текстові повідомлення від гри і, використовуючи `Dispatcher`, безпечно виводить їх у `TextBox` вікна.
* **Event-Driven:** Взаємодія базується на подіях натискання кнопок (`Click`).
* **Reuse (Повторне використання):** Клас `GameSession` був модифікований для підтримки покрокового виклику (`ExecuteRound` став публічним), що дозволило використати ту саму логіку, що і в консолі.

### 10.2. Структура вікна
Інтерфейс розділено на дві частини (Grid Layout):
1.  **Log Area (Зліва):** `TextBox` (ReadOnly) для відображення ходу бою.
2.  **Control Panel (Справа):** Кнопки керування:
    * `Start Game` — ініціалізація сесії.
    * `Next Turn` — виконання одного кроку бою.
    * `Save/Load` — робота з файловою системою через `Repository`.

## 11. Розгортання (Deployment)

Додаток розповсюджується у вигляді скомпільованих бінарних файлів (Portable Deployment).

### 11.1. Стратегія збірки
* **Конфігурація:** Release (з оптимізацією коду).
* **Метод:** Framework-dependent (вимагає встановленого .NET Runtime на машині користувача, що зменшує розмір дистрибутиву).
* **Артефакти:**
    * `OopPractice.WpfGui.exe` — точка входу для графічного режиму.
    * `OopPractice1.exe` — точка входу для CLI.
    * `*.dll` — бібліотеки бізнес-логіки (Core, Data, Infra).
    * `gamestate.json` — файл збереження (створюється автоматично в AppData).

### 11.2. Інструкція для користувача
Для запуску програми не потрібен інсталятор. Достатньо розпакувати архів і запустити виконуваний файл `.exe`.