# Design Document: OopPractice CLI Application

---

## 1. Вступ
Цей документ описує архітектуру та деталі реалізації консольного додатка, розробленого в рамках курсу ООП. Проєкт об'єднує в собі функціонал менеджера файлів, каталогу RPG-персонажів та текстової рольової гри.

**Головна мета:** Створення гнучкої, модульної архітектури, яка дозволяє легко додавати нові команди та режими роботи без зміни основного коду, використовуючи принципи SOLID та патерни проєктування.

---

## 2. Архітектура Системи

Додаток побудований за тришаровою архітектурою з акцентом на слабку зв'язаність (Loose Coupling).

### 2.1. Основні шари
1.  **Presentation Layer (Шар представлення):**
    * Відповідає за взаємодію з користувачем через консоль.
    * Містить класи `CliManager`, `IRenderer`, `IConsoleDriver`.
2.  **Logic/Core Layer (Шар бізнес-логіки):**
    * Містить сутності (`Character`, `Warrior`, `Mage`), логіку бою та управління файлами.
    * Визначає інтерфейси для стратегій (`ICommandStrategy`, `IAttackStrategy`).
3.  **Data Layer (Шар даних):**
    * Відповідає за збереження та завантаження стану.
    * Реалізовано через клас `Repository`, який серіалізує об'єкти в JSON.

---

## 3. Деталізація Командного Інтерфейсу (CLI)

Центральним елементом системи є гнучкий CLI, побудований на комбінації патернів **Facade**, **Strategy** та **Renderer**.

### 3.1. Патерн "Facade" (`CliManager`)
Клас `CliManager` виступає єдиною точкою входу для користувацького вводу.
* **Відповідальність:** Запускає цикл `Read-Eval-Print Loop` (REPL), парсить введені рядки на команди та аргументи.
* **Особливість:** Він не знає, як виконувати команди. Він лише делегує їх відповідним зареєстрованим делегатам (`Action<string[]>`).

### 3.2. Патерн "Strategy" (`ICommandStrategy`)
Для розділення логіки різних модулів використовується інтерфейс `ICommandStrategy`. Це дозволяє групувати команди за контекстом:
* **`CharacterManagementStrategy`**: Інкапсулює логіку роботи з персонажами (створення, перегляд, збереження). Реєструє команди: `create-char`, `ls-chars`, `info`, `save`.
* **`FileSystemStrategy` (Опціонально)**: Інкапсулює логіку роботи з файлами (`cd`, `dir`, `edit`).

*Перевага:* Щоб додати новий модуль (наприклад, "Магазин предметів"), потрібно лише створити нову стратегію та підключити її в `Program.cs` через `cli.UseStrategy(...)`.

### 3.3. Патерн "Renderer" (Розділення Представлення)
Для відділення логіки даних від їх візуалізації застосовано принцип інверсії залежностей.
* **Проблема:** Клас `Character` не повинен мати методів `PrintToConsole()`, оскільки це порушує SRP (Single Responsibility Principle).
* **Рішення:** Створено узагальнений інтерфейс `IRenderer<T>`.
    * Стратегія отримує дані (об'єкт `Character`).
    * Стратегія передає дані у `CharacterConsoleRenderer`.
    * Рендерер, використовуючи `IConsoleDriver`, формує красивий вивід (кольори, форматування).

---

## 4. Використані Патерни Проєктування

Проєкт активно використовує класичні GoF патерни:

| Патерн | Де використовується | Опис |
| :--- | :--- | :--- |
| **State (Стан)** | `FileManager` | Реалізує переходи між режимами: Навігація ↔ Перегляд файлу ↔ Редагування. |
| **Strategy (Стратегія)** | `CliManager`, `Character` | 1. Підключення груп команд CLI.<br>2. Реалізація різних типів атак (`MightyAxeStrategy`). |
| **Observer (Спостерігач)** | `BattleLogger` | Логування подій бою (отримання урону, смерть) без зміни коду персонажа. |
| **Memento (Знімок)** | `CharacterMemento` | Збереження стану персонажа для запису на диск. |
| **Factory Method** | `CharacterManagementStrategy` | Логіка створення персонажів (`Warrior` vs `Mage`) залежно від вибору користувача. |
| **Facade** | `CliManager` | Спрощений інтерфейс для роботи зі складною системою команд. |

---

## 5. Потік Даних (Data Flow)

**Сценарій: Створення персонажа**

1.  **Input:** Користувач вводить `create-char`.
2.  **Routing:** `CliManager` знаходить зареєстрований `Action` для цього ключа.
3.  **Processing:** Викликається метод `CreateCharacter` у `CharacterManagementStrategy`.
4.  **Interaction:** Користувач вводить ім'я та клас через консольний діалог.
5.  **Instantiation:** Створюється об'єкт `Warrior` або `Mage`.
6.  **Storage:** Об'єкт додається у локальний список `_characters`.
7.  **Feedback:** Виводиться повідомлення про успіх.

**Сценарій: Вивід інформації (`info`)**

1.  **Input:** Користувач вводить `info Conan`.
2.  **Search:** Стратегія шукає об'єкт в пам'яті за іменем.
3.  **Rendering:** Знайдений об'єкт передається у `_charRenderer.Render(character)`.
4.  **Output:** Рендерер малює кольорову картку персонажа в консоль.

---

## 6. Збереження Даних

Дані зберігаються у форматі **JSON** у файлі `gamestate.json`.
* Використовується клас `Repository`.
* При збереженні об'єкти конвертуються у DTO (`CharacterData`), щоб уникнути циклічних посилань та зберегти лише важливі дані.
* При завантаженні відбувається реконструкція об'єктів та відновлення їх стану через Memento.

---

## 7. Можливості для розширення

Архітектура дозволяє легко додати:
* **Графічний інтерфейс (GUI):** Достатньо написати нову реалізацію `IRenderer` (наприклад, `WpfRenderer`), не змінюючи логіку стратегій.
* **Мережева гра:** `CliManager` може приймати команди не з `Console.ReadLine`, а з мережевого сокету.
* **Нові ігрові механіки:** Додавання інвентарю або квестів через нові `ICommandStrategy`.

## 8. Бойова Система (Core Mechanics)

### 8.1. Формули розрахунку
В грі використовується система покрокового бою. Розрахунок пошкоджень відбувається за наступною формулою:

**Фізична атака:**
`Damage = max(0, Attacker.AttackPower - Target.Armor)`

**Магічна атака (Fireball):**
Магія ігнорує броню, але має фіксований урон.
`MagicDamage = SpellBaseDamage`

**Критичний удар (для Warrior):**
Шанс 20% нанести 150% шкоди.
`CritDamage = Damage * 1.5`

### 8.2. Структура ходу (Turn System)
Бій поділяється на раунди. У кожному раунді:
1. Визначається ініціатива (хто ходить першим).
2. Персонаж обирає дію (Атака, Здібність, Лікування).
3. Дія виконується, стан персонажів оновлюється.
4. Подія записується в `BattleHistory`.
5. Перевірка умов перемоги (HP <= 0).

### 8.3. Класи Core
* `GameSession`: Керує циклом гри, зберігає список гравців.
* `Turn`: Зберігає інформацію про одну дію (хто, кого, скільки урону).
* `BattleHistory`: Список всіх ходів для перегляду після бою.